<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Flasher - Tally Hub</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 2rem;
            color: white;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .back-button {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            text-decoration: none;
            color: white;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            margin-bottom: 2rem;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .device-selector {
            margin-bottom: 2rem;
        }

        .device-selector h3 {
            margin-bottom: 1rem;
            color: #fff;
            font-size: 1.5rem;
        }

        .device-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
        }

        .firmware-selector {
            margin: 1.5rem 0;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .firmware-selector h4 {
            margin-bottom: 1rem;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .firmware-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .firmware-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .firmware-option:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .firmware-option input[type="radio"] {
            margin-right: 0.5rem;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: inline-block;
            padding: 0.5rem 1rem;
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid rgba(33, 150, 243, 0.3);
            border-radius: 6px;
            color: #2196F3;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .file-input-label:hover {
            background: rgba(33, 150, 243, 0.3);
        }

        .file-selected {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-radius: 6px;
            color: #4CAF50;
            font-size: 0.9rem;
        }

        .device-option {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .device-option:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .device-option.selected {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }

        .device-option h4 {
            margin-bottom: 0.5rem;
            font-size: 1.2rem;
        }

        .device-option p {
            opacity: 0.8;
            font-size: 0.9rem;
        }
        .connection-instructions {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            display: none;
        }

        .connection-instructions h4 {
            color: #FFC107;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .connection-instructions ol {
            margin-left: 1.5rem;
        }

        .connection-instructions li {
            margin-bottom: 0.5rem;
            line-height: 1.5;
        }

        .firmware-info {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            display: none;
        }

        .firmware-info h4 {
            margin-bottom: 0.5rem;
            color: #4CAF50;
        }

        .flash-section {
            text-align: center;
            margin-top: 2rem;
        }

        .flash-button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            margin: 1rem 0;
            min-width: 200px;
        }

        .flash-button:hover:not(:disabled) {
            background: linear-gradient(45deg, #45a049, #4CAF50);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .secondary-button {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: #fff;
            border: none;
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(33,150,243,0.35);
            margin-left: 0.5rem;
            display: none;
        }
        .secondary-button:hover:not(:disabled){
            background: linear-gradient(45deg, #1976D2, #2196F3);
            transform: translateY(-1px);
        }

        .flash-button:disabled {
            background: #666;
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.6;
        }

        .progress-container {
            margin: 1rem 0;
            display: none;
        }

        .progress-bar {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            height: 20px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .progress-text {
            text-align: center;
            margin-top: 0.5rem;
            font-weight: 500;
        }

        .status {
            margin: 1rem 0;
            padding: 1rem;
            border-radius: 8px;
            font-weight: 500;
            display: none;
        }

        .status.info {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid rgba(33, 150, 243, 0.3);
            color: #2196F3;
        }

        .status.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.3);
            color: #4CAF50;
        }

        .status.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.3);
            color: #f44336;
        }

        .status.warning {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.3);
            color: #FFC107;
        }

        .note {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid rgba(33, 150, 243, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .note h4 {
            color: #2196F3;
            margin-bottom: 0.5rem;
        }

        /* Server flash fallback */
        #serverFlashContainer { margin-top:2rem; display:none; }
        #serverFlashContainer h3 { margin-bottom:0.75rem; }
        .inline-group { display:flex; gap:0.5rem; flex-wrap:wrap; align-items:flex-end; }
        .inline-group select, .inline-group button { padding:0.5rem; border-radius:6px; border:1px solid rgba(255,255,255,0.3); background:rgba(255,255,255,0.1); color:#fff; }
        .inline-group button { cursor:pointer; background:linear-gradient(45deg,#2196F3,#1976D2); border:none; }
        .inline-group button:hover { filter:brightness(1.1); }
        #serverFlashStatus { margin-top:0.75rem; white-space:pre-line; font-size:0.85rem; background:rgba(0,0,0,0.25); padding:0.75rem; border-radius:8px; max-height:220px; overflow:auto; }
        #toggleModeBtn { margin-top:0.5rem; background:linear-gradient(45deg,#ff9800,#f57c00); border:none; padding:0.4rem 0.8rem; border-radius:6px; color:#fff; cursor:pointer; font-size:0.8rem; }
        #toggleModeBtn:hover { filter:brightness(1.1); }
        .badge { background:#2196F3; padding:0.2rem 0.5rem; border-radius:4px; font-size:0.7rem; vertical-align:middle; }

        @media (max-width: 768px) {
            .device-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            body {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="/" class="back-button">← Back to Hub</a>
            <h1>🔧 ESP32 Firmware Flasher</h1>
            <p>Flash Tally Hub firmware to your ESP32 devices using your web browser</p>
        </div>

        <div class="card">
            <div class="device-selector">
                <h3>📱 Select Your Device Type</h3>
                <div class="device-grid">
                    <div class="device-option" onclick="selectDevice('ESP32-1732S019')">
                        <h4>ESP32-1732S019</h4>
                        <p>1.9" Display • Touch Screen • Budget-friendly</p>
                    </div>
                    <div class="device-option" onclick="selectDevice('M5Stick_Tally')">
                        <h4>M5Stick C Plus 1.1</h4>
                        <p>1.14" Display • Buttons • Premium Build</p>
                    </div>
                    <div class="device-option" onclick="selectDevice('M5Stick_Tally_Plus2')">
                        <h4>M5Stick C Plus2</h4>
                        <p>1.14" Display • Buttons • Latest hardware</p>
                    </div>
                </div>
            </div>

            <div id="connectionInstructions" class="connection-instructions">
                <h4>🔌 Connection Instructions</h4>
                <ol id="instructionsList">
                    <!-- Instructions will be populated by JavaScript -->
                </ol>
            </div>

            <div class="firmware-selector" id="firmwareSelector" style="display: none;">
                <h4>📦 Select Firmware Source</h4>
                <div class="firmware-options">
                    <label class="firmware-option">
                        <input type="radio" name="firmwareSource" value="builtin" checked>
                        <span>Use Built-in Firmware (Recommended)</span>
                    </label>
                    <label class="firmware-option">
                        <input type="radio" name="firmwareSource" value="custom">
                        <span>Browse for Custom .bin File</span>
                    </label>
                    <label class="firmware-option">
                        <input type="radio" name="firmwareSource" value="online">
                        <span>Fetch Latest from GitHub (Signed/Hashed)</span>
                    </label>
                </div>
                
                <div id="customFileSection" style="display: none; margin-top: 1rem;">
                    <div class="file-input-wrapper">
                        <input type="file" id="customFirmwareFile" class="file-input" accept=".bin" />
                        <label for="customFirmwareFile" class="file-input-label">
                            📁 Browse .bin File
                        </label>
                    </div>
                    <div id="fileSelected" class="file-selected" style="display: none;">
                        <span>📄 Selected: </span><span id="selectedFileName"></span>
                        <span> (</span><span id="selectedFileSize"></span><span>)</span>
                    </div>
                </div>
            </div>

            <div class="firmware-info" id="firmwareInfo">
                <h4>📦 Firmware Information</h4>
                <p><strong>Device:</strong> <span id="selectedDeviceName">None</span></p>
                <p><strong>Firmware File:</strong> <span id="firmwareFile">firmware-merged.bin</span></p>
                <p><strong>Flash Address:</strong> 0x0000 (Complete firmware)</p>
                <p><strong>Size:</strong> <span id="firmwareSize">~1MB</span></p>
            </div>

            <div class="flash-section">
                <button id="flashButton" class="flash-button" onclick="flashFirmware()" disabled>
                    📲 Flash Firmware
                </button>
                <button id="resetButton" class="secondary-button" onclick="manualReset()" title="Attempt a post-flash reset via serial (DTR/RTS)">🔁 Reset Device</button>
                
                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text" id="progressText">0%</div>
                </div>
                
                <div id="status" class="status"></div>
            </div>

            <div class="note">
                <h4>💡 Browser Requirements & Usage</h4>
                <p><strong>Browser:</strong> This flasher requires a Chromium-based browser (Chrome, Edge, Opera) with Web Serial API support.</p>
                <p><strong>Built-in Firmware:</strong> Use the recommended firmware that comes with IP display improvements.</p>
                <p><strong>Custom Firmware:</strong> Upload your own .bin firmware file for testing or custom builds.</p>
                <p><strong>Connection:</strong> Make sure your device is connected via USB and the appropriate drivers are installed.</p>
            </div>

            <div id="serverFlashContainer" class="card" style="background:rgba(0,0,0,0.25);">
                <h3>🖥️ Server Flash Mode <span class="badge">BETA</span></h3>
                <p style="opacity:0.85; font-size:0.9rem; margin-bottom:0.75rem;">Use this when Web Serial is unavailable or the device is plugged into the Tally Hub server (e.g. Raspberry Pi). The server must have <code>esptool.py</code> installed.</p>
                <div class="inline-group">
                    <div style="flex:1; min-width:160px;">
                        <label style="font-size:0.75rem; opacity:0.8;">Serial Port</label>
                        <select id="serverPortSelect"></select>
                    </div>
                    <div style="flex:1; min-width:200px;">
                        <label style="font-size:0.75rem; opacity:0.8;">Firmware</label>
                        <select id="serverFirmwareSelect"></select>
                    </div>
                    <div style="display:flex; gap:0.5rem;">
                        <button id="refreshServerListsBtn" type="button">🔄 Refresh</button>
                        <button id="startServerFlashBtn" type="button" style="background:linear-gradient(45deg,#4CAF50,#45a049);">⚡ Flash</button>
                    </div>
                </div>
                <div style="margin-top:0.75rem; font-size:0.75rem; opacity:0.7;">Ports are detected from /dev (USB/ACM/AMA/by-id). Firmware list comes from <code>/api/flash/firmware</code>.</div>
                <div id="serverFlashStatus"></div>
                <button id="toggleModeBtn" type="button" style="display:none;">Switch to Web Serial Mode</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { ESPLoader, Transport } from 'https://unpkg.com/esptool-js@0.4.6/bundle.js';

        let selectedDevice = null;
        let esploader = null;
        let transport = null;
        let customFirmwareFile = null;
    let manifest = null; // remote manifest
    let manifestEntry = null; // selected device entry
    let onlineFirmwareBuffer = null; // ArrayBuffer after download
    let lastPort = null; // retain port for post-flash reset attempt
    let autoResetPerformed = false;

        // Device configurations - simplified to single file only
        const deviceConfigs = {
            'ESP32-1732S019': {
                name: 'ESP32-1732S019',
                firmware: '/firmware/ESP32-1732S019/firmware-merged.bin',
                chip: 'esp32',
                flashSize: '8MB',
                instructions: [
                    'Connect your ESP32-1732S019 to your computer via USB-C cable',
                    'Hold the BOOT button while clicking "Flash Firmware"',
                    'Release the BOOT button when flashing starts',
                    'Wait for the process to complete (~2 minutes)'
                ]
            },
            'M5Stick_Tally': {
                name: 'M5Stick C Plus 1.1',
                firmware: '/firmware/M5Stick_Tally/firmware-merged.bin',
                chip: 'esp32',
                flashSize: '4MB',
                instructions: [
                    'Connect your M5Stick C Plus to your computer via USB-C cable',
                    'Turn on the device by pressing the power button (if needed)',
                    'Hold the HOME button (M5 button) while clicking "Flash Firmware"',
                    'Release the HOME button when flashing starts',
                    'Wait for the process to complete (~2 minutes)'
                ]
            },
            'M5Stick_Tally_Plus2': {
                name: 'M5Stick C Plus2',
                firmware: '/firmware/M5Stick_Tally_Plus2/firmware-merged.bin',
                chip: 'esp32',
                flashSize: '4MB',
                instructions: [
                    'Connect your M5Stick C Plus2 to your computer via USB-C cable',
                    'Turn on the device by pressing the power button (if needed)',
                    'Hold the HOME button (M5 button) while clicking "Flash Firmware"',
                    'Release the HOME button when flashing starts',
                    'Wait for the process to complete (~2 minutes)'
                ]
            }
        };

        window.selectDevice = function(deviceType) {
            // Remove selection from all devices
            document.querySelectorAll('.device-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            // Select the clicked device
            event.target.closest('.device-option').classList.add('selected');
            
            selectedDevice = deviceType;
            const config = deviceConfigs[deviceType];
            
            // Update device name and firmware info
            document.getElementById('selectedDeviceName').textContent = config.name;
            document.getElementById('firmwareInfo').style.display = 'block';
            
            // Show firmware selector
            document.getElementById('firmwareSelector').style.display = 'block';
            
            // Update connection instructions
            const instructionsList = document.getElementById('instructionsList');
            instructionsList.innerHTML = '';
            config.instructions.forEach(instruction => {
                const li = document.createElement('li');
                li.textContent = instruction;
                instructionsList.appendChild(li);
            });
            document.getElementById('connectionInstructions').style.display = 'block';
            
            // Enable flash button
            document.getElementById('flashButton').disabled = false;
            
            showStatus('Device selected: ' + config.name + '. Choose firmware source and click Flash!', 'info');
        };

        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
        }

        function updateProgress(percent) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const progressContainer = document.getElementById('progressContainer');
            
            progressContainer.style.display = 'block';
            progressFill.style.width = `${percent}%`;
            progressText.textContent = `${Math.round(percent)}%`;
        }

        window.flashFirmware = async function() {
            if (!selectedDevice) {
                showStatus('Please select a device type first', 'error');
                return;
            }

            // Check firmware source
            const firmwareSource = document.querySelector('input[name="firmwareSource"]:checked').value;
            if (firmwareSource === 'custom' && !customFirmwareFile) {
                showStatus('Please select a custom firmware file first', 'error');
                return;
            }
            if (firmwareSource === 'online' && !onlineFirmwareBuffer) {
                showStatus('Please fetch online firmware first (it will auto-fetch after selecting device).', 'error');
                return;
            }

            if (!navigator.serial) {
                showStatus('Web Serial API not supported. Please use Chrome, Edge, or Opera browser.', 'error');
                return;
            }

            const config = deviceConfigs[selectedDevice];
            const flashButton = document.getElementById('flashButton');
            
            try {
                // Disable button during flashing
                flashButton.disabled = true;
                flashButton.textContent = '🔄 Connecting...';
                
                showStatus('Requesting device connection...', 'info');
                
                // Request port access
                const port = await navigator.serial.requestPort();
                lastPort = port;
                transport = new Transport(port, true);
                
                showStatus('Connecting to device...', 'info');
                
                // Create ESP loader
                esploader = new ESPLoader({
                    transport: transport,
                    baudrate: 115200,
                    romBaudrate: 115200,
                    terminal: {
                        clean: () => {},
                        writeLine: (data) => console.log(data),
                        write: (data) => console.log(data)
                    }
                });

                // Connect to chip
                const chip = await esploader.main();
                showStatus(`Connected to ${chip}. Preparing firmware...`, 'info');
                updateProgress(10);

                // Get firmware data
                let firmwareData;
                let firmwareSize;
                
                if (firmwareSource === 'custom') {
                    // Use custom file
                    flashButton.textContent = '📁 Reading File...';
                    showStatus('Reading custom firmware file...', 'info');
                    firmwareData = await customFirmwareFile.arrayBuffer();
                    firmwareSize = (firmwareData.byteLength / 1024).toFixed(1);
                } else if (firmwareSource === 'online') {
                    if (!onlineFirmwareBuffer) throw new Error('Online firmware not loaded');
                    flashButton.textContent = '✅ Verified';
                    showStatus('Using verified online firmware (SHA256 OK)', 'info');
                    firmwareData = onlineFirmwareBuffer;
                    firmwareSize = (firmwareData.byteLength / 1024).toFixed(1);
                } else {
                    // Download built-in firmware
                    flashButton.textContent = '⬇️ Downloading...';
                    showStatus('Downloading built-in firmware...', 'info');
                    const response = await fetch(config.firmware + '?t=' + Date.now());
                    if (!response.ok) {
                        throw new Error(`Failed to download firmware: ${response.status}`);
                    }
                    firmwareData = await response.arrayBuffer();
                    firmwareSize = (firmwareData.byteLength / 1024).toFixed(1);
                }
                
                document.getElementById('firmwareSize').textContent = `${firmwareSize} KB`;
                
                showStatus(`Firmware ready (${firmwareSize} KB). Starting flash...`, 'info');
                updateProgress(30);

                // Convert to binary string for esptool-js
                const uint8Array = new Uint8Array(firmwareData);
                const binaryString = Array.from(uint8Array, byte => String.fromCharCode(byte)).join('');

                flashButton.textContent = '⚡ Flashing...';
                showStatus('Flashing firmware... Please do not disconnect the device.', 'warning');

                // Flash the firmware
                await esploader.writeFlash({
                    fileArray: [{
                        data: binaryString,
                        address: 0x0
                    }],
                    flashSize: config.flashSize,
                    flashMode: 'dio',
                    flashFreq: '80m',
                    eraseAll: false,
                    compress: true,
                    reportProgress: (fileIndex, written, total) => {
                        const progress = 30 + (written / total) * 65; // 30-95%
                        updateProgress(progress);
                        
                        if (written === total) {
                            updateProgress(100);
                            showStatus('Firmware flashed successfully! 🎉 Preparing reset...', 'success');
                        }
                    }
                });

                // Success!
                flashButton.textContent = '✅ Flash Complete';
                const firmwareType = firmwareSource === 'custom' ? 'custom' : (firmwareSource === 'online' ? 'online' : 'built-in');
                showStatus(`✅ ${firmwareType} firmware flashed successfully! Attempting automatic reset...`, 'success');

                // Try auto reset using transport toggling DTR/RTS
                try {
                    await attemptAutoReset();
                } catch(e) {
                    console.warn('Auto reset attempt failed:', e);
                }

                if (autoResetPerformed) {
                    showStatus('🔁 Device reset signal sent. If display doesn\'t update within 5s, press the power button briefly.', 'info');
                } else {
                    showStatus('⚠️ Auto reset not available in this browser/transport. Use the Reset Device button or press the power button.', 'warning');
                    document.getElementById('resetButton').style.display = 'inline-block';
                }
                
                // Add device-specific post-flash instructions
                if (selectedDevice === 'M5Stick_Tally') {
                    setTimeout(() => {
                        showStatus('📋 M5Stick Instructions: Disconnect USB, wait 5 seconds, then hold POWER button for 6 seconds to restart.', 'info');
                    }, 3000);
                }

            } catch (error) {
                console.error('Flash error:', error);
                showStatus(`Flash failed: ${error.message}`, 'error');
                flashButton.textContent = '❌ Flash Failed';
                updateProgress(0);
            } finally {
                // Re-enable button after some delay
                setTimeout(() => {
                    flashButton.disabled = false;
                    flashButton.textContent = '📲 Flash Firmware';
                }, 3000);
                
                // Cleanup
                // Keep port/transport open briefly to allow reset toggling, close later.
                setTimeout(async () => {
                  if (transport) {
                    try { await transport.disconnect(); } catch(e){ console.warn('Error disconnecting transport:', e); }
                  }
                }, 4000);
            }
        };

        async function attemptAutoReset(){
            if (!transport || !lastPort) return;
            // esptool-js Transport exposes setDTR/setRTS on underlying serial port; fallback to direct port if available
            const s = lastPort;
            if (!s.setSignals) return; // Web Serial API required
            try {
                // Standard reset pulse sequence
                await s.setSignals({ dataTerminalReady: false, requestToSend: true });
                await delay(120);
                await s.setSignals({ dataTerminalReady: false, requestToSend: false });
                await delay(80);
                await s.setSignals({ dataTerminalReady: true, requestToSend: false });
                autoResetPerformed = true;
            } catch(e) {
                console.warn('Reset pulse error:', e);
            }
        }

        window.manualReset = async function(){
            showStatus('Issuing manual reset pulse...', 'info');
            autoResetPerformed = false;
            await attemptAutoReset();
            if (autoResetPerformed) {
                showStatus('🔁 Reset signal sent. Device should reboot now.', 'success');
            } else {
                showStatus('⚠️ Reset signal could not be sent. Please press the device power/reset button.', 'warning');
            }
        }

        function delay(ms){ return new Promise(r=>setTimeout(r, ms)); }

        // ---- Online Manifest Support ----
        const MANIFEST_URL = 'https://raw.githubusercontent.com/tallyhubpro/Tallyhub/main/public/firmware/firmware-manifest.json'; // adjust if hosting elsewhere

        async function fetchManifest(){
            try {
                showStatus('Fetching firmware manifest...', 'info');
                const res = await fetch(MANIFEST_URL + '?t=' + Date.now(), { cache: 'no-store' });
                if(!res.ok) throw new Error('Manifest HTTP '+res.status);
                manifest = await res.json();
                showStatus('Manifest loaded. Latest version: ' + (manifest.latest || 'n/a'), 'info');
                if(selectedDevice){
                    await prepareOnlineFirmware();
                }
            } catch(e){
                console.warn('Manifest fetch failed', e);
                showStatus('Manifest fetch failed: '+ e.message, 'warning');
            }
        }

        async function prepareOnlineFirmware(){
            if(!manifest || !selectedDevice) return;
            const devKey = selectedDevice;
            const devEntry = manifest.devices?.[devKey];
            if(!devEntry){
                showStatus('No online firmware entry for '+ devKey, 'warning');
                return;
            }
            manifestEntry = devEntry;
            showStatus('Downloading online firmware for '+ devKey + ' (version '+ (devEntry.version||'n/a') +')', 'info');
            try {
                const buf = await downloadAndVerify(devEntry);
                onlineFirmwareBuffer = buf;
                showStatus('Online firmware ready ('+ (buf.byteLength/1024).toFixed(1)+' KB) ✓ hash verified', 'success');
                document.getElementById('firmwareSize').textContent = (buf.byteLength/1024).toFixed(1) + ' KB';
            } catch(e){
                showStatus('Online firmware download failed: '+ e.message, 'error');
            }
        }

        async function downloadAndVerify(entry){
            const r = await fetch(entry.url + '?t=' + Date.now(), { cache: 'no-store' });
            if(!r.ok) throw new Error('Firmware HTTP '+ r.status);
            const buf = await r.arrayBuffer();
            if(entry.sha256){
                const hashBuf = await crypto.subtle.digest('SHA-256', buf);
                const hex = Array.from(new Uint8Array(hashBuf)).map(b=>b.toString(16).padStart(2,'0')).join('');
                if(hex.toLowerCase() !== entry.sha256.toLowerCase()){
                    throw new Error('SHA256 mismatch expected '+ entry.sha256 +' got '+ hex);
                }
            }
            return buf;
        }

        // React to firmware source selection for 'online'
        document.querySelectorAll('input[name="firmwareSource"]').forEach(r => {
            r.addEventListener('change', async (e) => {
                if(e.target.value === 'online'){
                    if(!manifest) await fetchManifest(); else await prepareOnlineFirmware();
                }
            });
        });

        // Enhance selectDevice to auto-download when online is chosen
        const _origSelectDevice = window.selectDevice;
        window.selectDevice = function(deviceType){
            _origSelectDevice(deviceType);
            const src = document.querySelector('input[name="firmwareSource"]:checked')?.value;
            if(src === 'online'){
                prepareOnlineFirmware();
            }
        };

        // ---- Insecure Context Messaging ----
        (function(){
            const insecure = !window.isSecureContext && location.protocol !== 'https:' && location.hostname !== 'localhost';
            if(insecure){
                if(navigator.serial){
                    showStatus('⚠️ This page is not a secure context. Some serial features may be blocked soon by browsers.', 'warning');
                } else {
                    enableServerMode('🌐 Insecure remote origin blocks Web Serial');
                    showStatus('Remote HTTP origin prevents Web Serial. Using Server Flash Mode. For direct flashing, host this page over HTTPS or use localhost.', 'warning');
                }
            }
        })();

        // Initial manifest (lazy) fetch in background
        setTimeout(()=>{ fetchManifest().catch(()=>{}); }, 1500);

        // ---- Web Serial vs Server Fallback ----
        const serverFlashEl = document.getElementById('serverFlashContainer');
        const toggleModeBtn = document.getElementById('toggleModeBtn');
        let serverMode = false;

        function enableServerMode(autoReason){
            serverMode = true;
            serverFlashEl.style.display = 'block';
            toggleModeBtn.style.display = navigator.serial ? 'inline-block' : 'none';
            document.getElementById('flashButton').disabled = true;
            if(autoReason){
                showStatus(autoReason + ' – switched to Server Flash Mode.', 'warning');
            }
            refreshServerLists();
        }

        if (!navigator.serial) {
            enableServerMode('⚠️ Web Serial API not available');
        } else {
            toggleModeBtn.textContent = 'Use Server Flash Mode';
            toggleModeBtn.style.display = 'inline-block';
        }

        toggleModeBtn?.addEventListener('click', () => {
            if(serverMode){
                serverMode = false;
                serverFlashEl.style.display = 'none';
                showStatus('Returned to Web Serial mode. Select device and flash via browser.', 'info');
                if(selectedDevice) document.getElementById('flashButton').disabled = false;
                toggleModeBtn.textContent = 'Use Server Flash Mode';
            } else {
                enableServerMode('🔁 Manual switch');
                toggleModeBtn.textContent = 'Switch to Web Serial Mode';
            }
        });

        // ---- Server Flash Mode logic ----
        let currentJobId = null;
        const serverStatusBox = document.getElementById('serverFlashStatus');
        const portSelect = document.getElementById('serverPortSelect');
        const fwSelect = document.getElementById('serverFirmwareSelect');
        const refreshBtn = document.getElementById('refreshServerListsBtn');
        const startBtn = document.getElementById('startServerFlashBtn');

        function serverLog(msg){
            const ts = new Date().toISOString().split('T')[1].split('Z')[0];
            serverStatusBox.textContent += `[${ts}] ${msg}\n`;
            serverStatusBox.style.display = 'block';
            serverStatusBox.scrollTop = serverStatusBox.scrollHeight;
        }

        async function refreshServerLists(){
            try {
                serverLog('Refreshing ports & firmware...');
                const [portsResp, fwResp] = await Promise.all([
                    fetch('/api/flash/ports'),
                    fetch('/api/flash/firmware')
                ]);
                const portsJson = await portsResp.json();
                const fwJson = await fwResp.json();
                portSelect.innerHTML = '';
                (portsJson.ports || []).forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p; opt.textContent = p; portSelect.appendChild(opt);
                });
                if(!portSelect.value) serverLog('No ports detected yet. Plug device & Refresh.');
                fwSelect.innerHTML = '';
                (fwJson.files || []).forEach(f => {
                    const opt = document.createElement('option');
                    opt.value = f; opt.textContent = f; fwSelect.appendChild(opt);
                });
                if(selectedDevice){
                    const cfg = deviceConfigs[selectedDevice];
                    if(cfg){
                        const rel = cfg.firmware.replace('/firmware/','');
                        const tail = rel.split('/').slice(-1)[0];
                        const match = Array.from(fwSelect.options).find(o=>o.value.endsWith(tail));
                        if(match) fwSelect.value = match.value;
                    }
                }
                serverLog('Lists updated.');
            } catch(e){
                serverLog('Error refreshing lists: ' + e.message);
            }
        }

        async function startServerFlash(){
            if(!portSelect.value){ serverLog('Select a port first.'); return; }
            if(!fwSelect.value){ serverLog('Select firmware first.'); return; }
            startBtn.disabled = true; refreshBtn.disabled = true;
            serverLog('Starting flash job...');
            try {
                const body = { port: portSelect.value, firmware: fwSelect.value, chip: 'esp32' };
                const resp = await fetch('/api/flash/jobs', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
                const json = await resp.json();
                if(!json.success){ serverLog('Failed to start job: '+ json.error); startBtn.disabled=false; refreshBtn.disabled=false; return; }
                currentJobId = json.job.id;
                serverLog('Job started: ' + currentJobId);
                pollJob();
            } catch(e){
                serverLog('Error starting job: '+ e.message);
                startBtn.disabled=false; refreshBtn.disabled=false;
            }
        }

        async function pollJob(){
            if(!currentJobId) return;
            try {
                const r = await fetch('/api/flash/jobs/' + currentJobId);
                if(!r.ok){ serverLog('Job lookup failed (status '+r.status+').'); return; }
                const j = await r.json();
                if(!j.success){ serverLog('Job error: '+ j.error); return; }
                const job = j.job;
                const lastLine = job.log[job.log.length-1];
                serverLog('Status: '+ job.status + (lastLine ? ' | '+ lastLine : ''));
                if(job.status === 'running'){
                    setTimeout(pollJob, 1500);
                } else {
                    serverLog('Job finished: ' + job.status);
                    startBtn.disabled=false; refreshBtn.disabled=false;
                }
            } catch(e){
                serverLog('Poll error: '+ e.message);
                setTimeout(pollJob, 2500);
            }
        }

        refreshBtn?.addEventListener('click', refreshServerLists);
        startBtn?.addEventListener('click', startServerFlash);

        // Handle firmware source selection
        document.querySelectorAll('input[name="firmwareSource"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const customSection = document.getElementById('customFileSection');
                if (this.value === 'custom') {
                    customSection.style.display = 'block';
                } else {
                    customSection.style.display = 'none';
                    customFirmwareFile = null;
                    document.getElementById('fileSelected').style.display = 'none';
                }
            });
        });

        // Handle custom file selection
        document.getElementById('customFirmwareFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                if (!file.name.toLowerCase().endsWith('.bin')) {
                    showStatus('Please select a .bin file', 'error');
                    this.value = '';
                    return;
                }
                
                customFirmwareFile = file;
                const fileSize = (file.size / 1024).toFixed(1);
                document.getElementById('selectedFileName').textContent = file.name;
                document.getElementById('selectedFileSize').textContent = `${fileSize} KB`;
                document.getElementById('fileSelected').style.display = 'block';
                
                showStatus(`Custom firmware file selected: ${file.name} (${fileSize} KB)`, 'info');
            }
        });
    </script>
</body>
</html>